<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Crypto Tycoon - Paz Games</title>
    <style>
        body { margin: 0; background: #020617; color: #fff; font-family: monospace; overflow: hidden; }
        canvas { display: block; image-rendering: pixelated; cursor: crosshair; }
        #ui { position: absolute; top: 15px; left: 15px; pointer-events: none; background: rgba(15, 23, 42, 0.95); padding: 15px; border: 1px solid #334155; border-radius: 6px; border-left: 4px solid #38bdf8; min-width: 260px; }
        .row { display: flex; justify-content: space-between; margin-bottom: 4px; font-size: 12px; }
        .val { color: #38bdf8; font-weight: bold; }
        .warn { color: #ef4444; animation: blink 1s infinite; display: none; text-align: center; margin-top: 5px; font-weight: bold;}
        @keyframes blink { 50% { opacity: 0.5; } }
        #inspect { position: absolute; right: 15px; top: 15px; width: 220px; background: #0f172a; border: 1px solid #334155; padding: 15px; display: none; pointer-events: auto; }
        button { width: 100%; background: #1e293b; border: 1px solid #475569; color: #38bdf8; padding: 5px; margin-top: 5px; cursor: pointer; transition: 0.2s;}
        button:hover { background: #334155; }
        kbd { background: #1e293b; padding: 2px 4px; border-radius: 3px; border: 1px solid #475569; color: #fff; }
        .toggle-btn { background: #0f766e; color: #ccfbf1; font-weight: bold; }
        .toggle-off { background: #7f1d1d; color: #fecaca; }
        .cancel-btn { background: #be123c; color: #ffe4e6; font-weight: bold; margin-left: 5px; }
    </style>
</head>
<body>
    <div id="ui">
        <div style="margin-bottom:10px; font-weight:bold; color:#f8fafc">PAZ GAMES | CRYPTO TYCOON</div>
        <div class="row"><span>MODO</span><span id="mode" class="val">NORMAL</span></div>
        <div class="row"><span>RED</span><span class="val"><span id="watts">0</span> / 5000 W</span></div>
        <div class="row"><span>TEMP MAX</span><span id="temp" class="val">24.0</span>¬∞C</div>
        <div class="row"><span>RUIDO MAX</span><span id="noise" class="val">0</span> dB</div>
        <div id="alert" class="warn">‚ö†Ô∏è SOBRECARGA ‚ö†Ô∏è</div>
        
        <div style="pointer-events: auto; margin-top: 10px; display: flex;">
            <button id="view-toggle" class="toggle-btn" onclick="toggleAutoView()" style="flex: 2;">üîí AUTO-VISTA</button>
            <button class="cancel-btn" onclick="setCursorMode()" style="flex: 1;">üö´ ESC</button>
        </div>

        <div style="margin-top:10px; font-size:10px; color:#94a3b8; line-height:1.6;">
            <kbd>Q</kbd> NORMAL <kbd>T</kbd> TERMAL <kbd>E</kbd> ELEC <kbd>R</kbd> RUIDO <kbd>S</kbd> SUCIO<br>
            <kbd>1</kbd> MINER <kbd>2</kbd> CABLE <kbd>3</kbd> AC-PISO <kbd>4</kbd> AC-PARED <kbd>5</kbd> FOAM<br>
            <span style="color:#fbbf24; display:block; margin-top:5px;">[SHIFT] + DRAG: LINEA RECTA</span>
        </div>
    </div>

    <div id="inspect">
        <div style="color:#38bdf8; font-weight:bold; margin-bottom:10px;">MINER S1 (2013)</div>
        <div class="row"><span>ESTADO</span><span id="ins-stat">OK</span></div>
        <div class="row"><span>TEMP</span><span id="ins-temp">0</span>¬∞C</div>
        <div class="row"><span>AIRFLOW</span><span id="ins-air">--</span></div>
        <button onclick="repair()">üîß REPARAR</button>
        <button onclick="sell()">üí∞ VENDER</button>
        <button onclick="closeIns()">‚ùå CERRAR</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const TILE_W = 64, TILE_H = 32, GRID = 10, AMB_TEMP = 24.0, MAX_WATTS = 5000;
        
        const state = {
            cam: { x: window.innerWidth/2, y: 150, z: 1.2 },
            mouse: { x:0, y:0, gx:0, gy:0, wall: null, down: false },
            dragStart: null, // Para guardar el inicio del drag
            ents: [],
            heat: new Float32Array(GRID*GRID).fill(AMB_TEMP),
            noise: new Float32Array(GRID*GRID).fill(30),
            dirt: new Float32Array(GRID*GRID).fill(0),
            particles: [], 
            view: 'normal', build: 'miner', tick: 0, nextId: 0, sel: null, overload: false,
            autoView: true, 
            circuitBreaker: true 
        };

        const iso = {
            toScreen: (gx, gy, gz=0) => ({
                x: (gx - gy) * (TILE_W/2) * state.cam.z + state.cam.x,
                y: (gx + gy) * (TILE_H/2) * state.cam.z + state.cam.z + state.cam.y - (gz * TILE_H * state.cam.z)
            }),
            toGrid: (sx, sy) => {
                const adjX = (sx - state.cam.x) / state.cam.z;
                const adjY = (sy - state.cam.y) / state.cam.z;
                return {
                    x: Math.floor((adjX / (TILE_W/2) + adjY / (TILE_H/2)) / 2),
                    y: Math.floor((adjY / (TILE_H/2) - adjX / (TILE_W/2)) / 2)
                };
            }
        };

        class Ent {
            constructor(id, x, y, type) {
                this.id = id; this.x = x; this.y = y; this.type = type;
                this.on = false; this.stat = 'ok';
                // Valores base ajustados para Fase 3 Final
                this.w = type==='miner'?450 : type.startsWith('ac')?800 : 0; // AC consume m√°s
                this.heat = type==='miner'?0.45 : type.startsWith('ac')?-0.2 : 0; // AC base
                this.noise = type==='miner'?75 : type.startsWith('ac')?50 : 0;
                this.airflowBlocked = false; // Nueva propiedad
            }
        }

        // --- FUNCIONES DE DIBUJO ---
        const drawWall = (gx, gy, isRight, type, powered) => {
            const z = state.cam.z;
            const w = TILE_W * z, h = TILE_H * z;
            const p = iso.toScreen(gx, gy); 
            ctx.fillStyle = isRight ? '#1e293b' : '#334155';
            ctx.beginPath();

            const isDoor = !isRight && gy === 5;

            if (!isRight) {
                const baseX = p.x + w/2; 
                const baseY = p.y + h/2; 
                ctx.moveTo(baseX, baseY); 
                ctx.lineTo(baseX, baseY - h*3); 
                ctx.lineTo(baseX - w/2, baseY - h*2.5); 
                ctx.lineTo(baseX - w/2, baseY + h/2); 
                ctx.fill(); ctx.strokeStyle = '#475569'; ctx.stroke();

                if(isDoor) {
                    ctx.fillStyle = '#0f172a'; // Marco
                    ctx.fillRect(baseX - w*0.4, baseY - h*2.2, w*0.35, h*2.2);
                    ctx.fillStyle = state.overload || !state.circuitBreaker ? '#ef4444' : '#22c55e'; // Panel Biom√©trico
                    ctx.fillRect(baseX - w*0.1, baseY - h*1.5, 2*z, 4*z);
                } else {
                    if(type === 'ac_wall') {
                        ctx.fillStyle = powered && !state.overload && state.circuitBreaker ? '#f8fafc' : '#64748b';
                        ctx.fillRect(baseX - w*0.4, baseY - h*2, w*0.3, h*0.4);
                        if(powered && !state.overload && state.circuitBreaker) { ctx.fillStyle = '#38bdf8'; ctx.fillRect(baseX - w*0.15, baseY - h*1.9, 2*z, 2*z); }
                    }
                    if(type === 'socket') {
                        ctx.fillStyle = state.circuitBreaker ? '#fbbf24' : '#ef4444'; ctx.beginPath();
                        ctx.arc(baseX - w*0.25, baseY - h*0.5, 3*z, 0, 7); ctx.fill();
                    }
                }
            } else {
                const baseX = p.x - w/2;
                const baseY = p.y + h/2;
                ctx.moveTo(baseX, baseY);
                ctx.lineTo(baseX, baseY - h*3);
                ctx.lineTo(baseX + w/2, baseY - h*2.5);
                ctx.lineTo(baseX + w/2, baseY + h/2);
                ctx.fill(); ctx.strokeStyle = '#475569'; ctx.stroke();

                if(type === 'ac_wall') {
                    ctx.fillStyle = powered && !state.overload && state.circuitBreaker ? '#f8fafc' : '#64748b';
                    ctx.fillRect(baseX + w*0.1, baseY - h*2, w*0.3, h*0.4);
                    if(powered && !state.overload && state.circuitBreaker) { ctx.fillStyle = '#38bdf8'; ctx.fillRect(baseX + w*0.35, baseY - h*1.9, 2*z, 2*z); }
                }
            }
        };

        const drawFoam = (p, w, h, z, ghost=false) => {
            if(ghost) ctx.globalAlpha = 0.5;
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(p.x + w/2, p.y + h/2);
            ctx.lineTo(p.x, p.y + h);
            ctx.lineTo(p.x - w/2, p.y + h/2);
            ctx.closePath();
            ctx.fillStyle = '#475569'; ctx.fill();
            ctx.strokeStyle = '#334155'; ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(p.x - w*0.2, p.y + h*0.4); ctx.lineTo(p.x + w*0.2, p.y + h*0.8);
            ctx.moveTo(p.x - w*0.1, p.y + h*0.3); ctx.lineTo(p.x + w*0.3, p.y + h*0.7);
            ctx.stroke();
            if(ghost) ctx.globalAlpha = 1.0;
        };

        const drawMiner = (e, p, w, h, z, ghost=false) => {
            const burn = e.stat === 'burn';
            const dead = e.stat === 'dead';
            if(ghost) ctx.globalAlpha = 0.5;
            ctx.fillStyle = dead ? '#000' : (burn ? '#450a0a' : (e.on && !state.overload && state.circuitBreaker ? '#cbd5e1' : '#475569'));
            ctx.beginPath();
            ctx.moveTo(p.x, p.y + h*0.2); ctx.lineTo(p.x + w*0.35, p.y);
            ctx.lineTo(p.x + w*0.35, p.y - h*0.7); ctx.lineTo(p.x, p.y - h*0.5);
            ctx.lineTo(p.x - w*0.35, p.y - h*0.7); ctx.lineTo(p.x - w*0.35, p.y);
            ctx.fill();

            if(!dead && !ghost) {
                ctx.fillStyle = '#00000033'; ctx.beginPath(); ctx.arc(p.x, p.y - h*0.25, w*0.12, 0, 7); ctx.fill();
                if(e.on && !state.overload && state.circuitBreaker) {
                    ctx.fillStyle = burn ? '#ef4444' : '#22c55e'; ctx.fillRect(p.x - w*0.3, p.y - h*0.6, 3*z, 3*z);
                }
            }
            if(ghost) ctx.globalAlpha = 1.0;
            if(burn) ctx.fillText("üî•", p.x-5, p.y-h);
            if(dead) ctx.fillText("üíÄ", p.x-5, p.y-h);
            // Indicador visual de falta de aire
            if(e.airflowBlocked && !ghost) {
                ctx.fillStyle = '#ef4444'; ctx.fillText("‚ö†Ô∏è", p.x+10*z, p.y-h);
            }
        };

        const drawCable = (e, p, z, ghost=false) => {
            if(ghost) ctx.globalAlpha = 0.5;
            ctx.strokeStyle = e.on && !state.overload && state.circuitBreaker ? '#38bdf8' : '#334155';
            ctx.lineWidth = 3*z;
            ctx.beginPath();
            [[1,0],[0,1]].forEach(([dx,dy]) => {
                const exists = ghost ? false : state.ents.some(k=>k.x===e.x+dx && k.y===e.y+dy);
                if(exists) {
                    const n = iso.toScreen(e.x+dx, e.y+dy);
                    ctx.moveTo(p.x, p.y+10*z); ctx.lineTo(n.x, n.y+10*z);
                }
            });
            ctx.stroke();
            ctx.fillStyle = e.on && !state.overload && state.circuitBreaker ? '#fff' : '#1e293b'; 
            ctx.beginPath(); ctx.arc(p.x, p.y+10*z, 3*z, 0, 7); ctx.fill();
            if(ghost) ctx.globalAlpha = 1.0;
        }

        const getTargetGrid = (e) => {
            const r = canvas.getBoundingClientRect();
            const mx = e.clientX - r.left; 
            const my = e.clientY - r.top;
            let g = iso.toGrid(mx, my);
            let gx = g.x; 
            let gy = g.y;

            // L√≥gica de Shift (L√≠nea Recta)
            if (e.shiftKey && state.dragStart) {
                const dx = Math.abs(gx - state.dragStart.x);
                const dy = Math.abs(gy - state.dragStart.y);
                if (dx > dy) gy = state.dragStart.y; // Bloqueo Eje Y
                else gx = state.dragStart.x; // Bloqueo Eje X
            }
            return {gx, gy};
        }

        const drawGhost = (e) => {
            if(!state.build) return; 
            const {gx, gy} = state.mouse; 
            
            // Usamos las coordenadas ajustadas por Shift si aplica
            // Pero como drawGhost se llama en loop, usamos state.mouse que se actualiza en onmousemove
            
            let tx=gx, ty=gy;
            let valid = true;
            
            const wall = (tx===-1 && ty>=0)?'left' : (ty===-1 && tx>=0)?'right' : null;

            if(state.build==='ac_wall') {
                if(wall==='left') tx=-1; else if(wall==='right') ty=-1; else valid=false;
            } else if(tx<0||ty<0||tx>=GRID||ty>=GRID) valid=false;

            if(valid) {
                const p = iso.toScreen(tx, ty);
                const z = state.cam.z;
                const fake = new Ent(-1, tx, ty, state.build);
                fake.on = true; 
                
                if(state.build==='miner') drawMiner(fake, p, TILE_W*z, TILE_H*z, z, true);
                else if(state.build==='cable') drawCable(fake, p, z, true);
                else if(state.build==='ac_floor') {
                    ctx.globalAlpha=0.5; ctx.fillStyle='#f1f5f9'; ctx.fillRect(p.x-15*z, p.y-40*z, 30*z, 50*z); ctx.globalAlpha=1;
                }
                else if(state.build==='ac_wall') {
                     ctx.globalAlpha=0.5; ctx.fillStyle='#f8fafc'; 
                     if(tx===-1) ctx.fillRect(p.x+15*z, p.y-40*z, 20*z, 15*z); 
                     else ctx.fillRect(p.x-35*z, p.y-40*z, 20*z, 15*z);
                     ctx.globalAlpha=1;
                }
                else if(state.build==='foam') drawFoam(p, TILE_W*z, TILE_H*z, z, true);
            }
        }

        const drawParticles = () => {
            state.particles.forEach((p, i) => {
                const pos = iso.toScreen(p.x, p.y);
                const z = state.cam.z;
                ctx.fillStyle = p.col;
                ctx.globalAlpha = p.life;
                ctx.beginPath();
                ctx.arc(pos.x + p.ox*z, pos.y - (1-p.life)*50*z, p.size*z, 0, 7);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            });
        }

        const drawSpawn = () => {
            const p = iso.toScreen(-1, 5);
            const z = state.cam.z;
            ctx.save();
            ctx.translate(p.x + 30*z, p.y + 10*z);
            ctx.scale(1, 0.5); 
            ctx.beginPath();
            ctx.arc(0, 0, 15*z, 0, Math.PI*2);
            ctx.fillStyle = 'rgba(56, 189, 248, 0.3)';
            ctx.fill();
            ctx.strokeStyle = '#38bdf8';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.restore();
            ctx.fillStyle = '#fff'; ctx.font = `${10*z}px monospace`;
            ctx.fillText("SPAWN", p.x + 15*z, p.y - 10*z + Math.sin(state.tick*0.1)*5);
        }

        // --- BUCLE PRINCIPAL ---
        function update() {
            state.tick++;
            
            // 1. Electricidad
            let load = 0;
            state.ents.forEach(e => e.on = (e.type === 'socket' && state.circuitBreaker));
            
            if(state.circuitBreaker) {
                const q = state.ents.filter(e => e.type === 'socket');
                const v = new Set();
                while(q.length) {
                    const c = q.shift(); v.add(`${c.x},${c.y}`);
                    state.ents.forEach(n => {
                        if(v.has(`${n.x},${n.y}`)) return;
                        if(Math.abs(n.x-c.x) + Math.abs(n.y-c.y) <= 1) {
                            if(n.type==='cable' || n.type==='socket' || n.type==='miner' || n.type.startsWith('ac') || n.type==='foam') {
                                n.on = true;
                                if((n.type==='cable' || n.type==='socket') && !v.has(`${n.x},${n.y}`)) q.push(n);
                            }
                        }
                    });
                }
            }
            
            load = state.ents.reduce((a,b) => a + (b.on && b.stat!=='dead' ? b.w : 0), 0);
            state.overload = load > MAX_WATTS;
            
            if(state.overload && state.circuitBreaker && Math.random() < 0.01) {
                state.circuitBreaker = false;
                alert("¬°APAG√ìN! Sobrecarga detectada. Reinicia el panel el√©ctrico.");
            }

            document.getElementById('watts').innerText = load;
            document.getElementById('alert').style.display = state.overload ? 'block' : 'none';

            // 2. Part√≠culas
            if(state.tick % 5 === 0) {
                state.ents.filter(e => e.stat === 'burn').forEach(e => {
                    state.particles.push({
                        x: e.x, y: e.y, ox: (Math.random()-0.5)*30, 
                        life: 1.0, size: Math.random()*3+1, 
                        col: Math.random()>0.5 ? '#fbbf24' : '#57534e'
                    });
                });
            }
            for(let i = state.particles.length-1; i>=0; i--) {
                state.particles[i].life -= 0.02;
                if(state.particles[i].life <= 0) state.particles.splice(i, 1);
            }

            // 3. F√≠sica (Calor, Ruido, Suciedad)
            let nextH = new Float32Array(state.heat);
            let nextN = new Float32Array(GRID*GRID).fill(30);
            
            for(let i=0; i<state.heat.length; i++) {
                const gx = i % GRID, gy = Math.floor(i / GRID);
                let t = state.heat[i];
                
                state.ents.forEach(e => {
                    if(!e.on || e.stat==='dead' || state.overload || !state.circuitBreaker) return;
                    const d = Math.sqrt((e.x-gx)**2 + (e.y-gy)**2);
                    const hasFoamUnder = state.ents.some(f => f.type === 'foam' && f.x === e.x && f.y === e.y);

                    if(e.type==='miner' && e.x===gx && e.y===gy) {
                        let bonus = 1;
                        
                        // Calor Radial Contiguo (+25% por vecino)
                        [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy]) => {
                            if(state.ents.some(k => k.x===gx+dx && k.y===gy+dy && k.type==='miner')) bonus += 0.25;
                        });

                        // L√≥gica de Flujo de Aire (Requiere espacio atr√°s)
                        // Asumimos "atr√°s" como Norte (y-1) por la isom√©trica estandar
                        // Si hay un bloque s√≥lido (Muro, Minero, AC) en y-1, se ahoga.
                        const blockedBack = state.ents.some(b => b.x === gx && b.y === gy-1 && b.type !== 'cable' && b.type !== 'foam');
                        const wallBack = (gy - 1 < 0); // Muro del borde
                        e.airflowBlocked = blockedBack || wallBack;
                        
                        if(e.airflowBlocked) bonus += 0.5; // +50% calor si est√° ahogado

                        if(hasFoamUnder) bonus += 0.15; 

                        t += e.heat * bonus;
                        if(t > 95) e.stat = 'dead'; else if(t > 80) e.stat = 'burn'; else e.stat = 'ok';
                    }
                    
                    if(e.type.startsWith('ac')) {
                        // Radio AC_FLOOR = 3, AC_WALL = 5 (Mejorado)
                        const radio = e.type === 'ac_floor' ? 3.0 : 5.0;
                        if (d <= radio) {
                            // Decaimiento lineal
                            t += e.heat * (1 - d/radio);
                        }
                    }
                    
                    if(e.noise > 0) {
                        let noiseVal = e.noise;
                        if(hasFoamUnder) noiseVal -= 20;
                        nextN[i] += Math.max(0, (noiseVal/(d+1)));
                    }
                });
                
                t += (AMB_TEMP - t) * 0.02;
                nextH[i] = t;
                state.dirt[i] = Math.min(100, state.dirt[i] + 0.002);
            }
            state.heat = nextH; state.noise = nextN;
            
            document.getElementById('temp').innerText = Math.max(...state.heat).toFixed(1);
            document.getElementById('noise').innerText = Math.max(...state.noise).toFixed(0);
            
            if(state.sel) {
                const idx = state.sel.x + state.sel.y * GRID;
                document.getElementById('ins-stat').innerText = state.sel.stat.toUpperCase();
                document.getElementById('ins-temp').innerText = state.heat[idx].toFixed(1);
                // Nuevo dato de inspecci√≥n
                document.getElementById('ins-air').innerText = state.sel.airflowBlocked ? "BLOQUEADO (CALOR ++)" : "FLUJO √ìPTIMO";
                document.getElementById('ins-air').style.color = state.sel.airflowBlocked ? '#ef4444' : '#22c55e';
            }
        }

        function draw() {
            ctx.clearRect(0,0, canvas.width, canvas.height);
            
            // 1. Paredes
            for(let y=0; y<GRID; y++) {
                const ent = state.ents.find(e => e.x===-1 && e.y===y);
                drawWall(-1, y, false, ent?.type, ent?.on);
            }
            for(let x=0; x<GRID; x++) {
                const ent = state.ents.find(e => e.x===x && e.y===-1);
                drawWall(x, -1, true, ent?.type, ent?.on);
            }

            // 2. Suelo
            for(let x=0; x<GRID; x++) {
                for(let y=0; y<GRID; y++) {
                    const p = iso.toScreen(x,y);
                    const z = state.cam.z;
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(p.x + TILE_W*z/2, p.y + TILE_H*z/2);
                    ctx.lineTo(p.x, p.y + TILE_H*z);
                    ctx.lineTo(p.x - TILE_W*z/2, p.y + TILE_H*z/2);
                    ctx.fill();
                    
                    let col = (x+y)%2===0 ? '#1e293b' : '#0f172a';
                    if(state.mouse.gx===x && state.mouse.gy===y) col = '#334155';
                    ctx.fillStyle = col; ctx.fill();
                    
                    if(state.view==='thermal') {
                        const t = state.heat[x+y*GRID];
                        ctx.fillStyle = t<15?'#00f5': t<35?'#0f05': t<70?'#fa05':'#f006'; ctx.fill();
                    }
                    if(state.view==='noise') { ctx.fillStyle = `rgba(255,255,255,${state.noise[x+y*GRID]/150})`; ctx.fill(); }
                    if(state.view==='dirt') { ctx.fillStyle = `rgba(100,80,50,${state.dirt[x+y*GRID]/100})`; ctx.fill(); }
                }
            }

            drawSpawn();

            // 3. CAPA DE FOAM
            state.ents.filter(e => e.type === 'foam').forEach(e => {
                const p = iso.toScreen(e.x, e.y);
                const z = state.cam.z;
                drawFoam(p, TILE_W*z, TILE_H*z, z);
            });

            // 4. Objetos del Suelo
            state.ents.sort((a,b) => (a.x+a.y)-(b.x+b.y)).forEach(e => {
                if(e.x<0 || e.y<0) return; 
                if(e.type === 'cable' || e.type === 'foam') return; 
                
                const p = iso.toScreen(e.x, e.y);
                const z = state.cam.z;
                
                if(e.type==='miner') drawMiner(e, p, TILE_W*z, TILE_H*z, z);
                if(e.type==='ac_floor') {
                    ctx.fillStyle = e.on && !state.overload && state.circuitBreaker ? '#f1f5f9' : '#94a3b8';
                    ctx.fillRect(p.x - 15*z, p.y - 40*z, 30*z, 50*z); 
                    if(e.on && !state.overload && state.circuitBreaker) { 
                        ctx.fillStyle = '#38bdf8'; ctx.fillRect(p.x - 5*z, p.y - 35*z, 4*z, 4*z);
                    }
                }
            });

            // 5. Cables
            if(state.view === 'electric') {
                state.ents.filter(e => e.type === 'cable').sort((a,b) => (a.x+a.y)-(b.x+b.y)).forEach(e => {
                    const p = iso.toScreen(e.x, e.y);
                    drawCable(e, p, state.cam.z);
                });
            }

            // Ghost solo se dibuja si estamos construyendo (no en drag si no queremos, pero aqui lo dejamos)
            drawGhost(); 
            drawParticles();
        }

        // --- MANEJO DE VISTA CONTEXTUAL ---
        function setViewForBuild(item) {
            if(!state.autoView) return; 
            const map = {'miner': 'normal', 'cable': 'electric', 'ac_floor': 'thermal', 'ac_wall': 'thermal', 'foam': 'noise'};
            if(map[item]) {
                state.view = map[item];
                document.getElementById('mode').innerText = state.view.toUpperCase();
            }
        }

        function toggleAutoView() {
            state.autoView = !state.autoView;
            const btn = document.getElementById('view-toggle');
            if(state.autoView) { btn.innerText = "üîí AUTO-VISTA"; btn.className = "toggle-btn"; }
            else { btn.innerText = "üîì MANUAL"; btn.className = "toggle-btn toggle-off"; }
        }

        function setCursorMode() {
            state.build = null; state.sel = null;
            document.getElementById('inspect').style.display = 'none'; 
        }

        function tryBuild(tx, ty) {
            if(!state.build) return;
            const wall = (tx===-1 && ty>=0)?'left' : (ty===-1 && tx>=0)?'right' : null;
            
            if(state.build==='ac_wall') {
                if(wall==='left') tx=-1; else if(wall==='right') ty=-1; else return;
            } else if(tx<0 || ty<0) return;

            if(state.build === 'cable' && state.view !== 'electric' && state.autoView) {
                 state.view = 'electric'; document.getElementById('mode').innerText = "ELECTRIC";
            }

            const hasSameType = state.ents.some(e => e.x===tx && e.y===ty && e.type === state.build);
            const hasFurniture = state.ents.some(e => e.x===tx && e.y===ty && e.type !== 'cable' && e.type !== 'foam');
            
            let allowed = false;
            
            if (state.build === 'cable') { if (!hasSameType) allowed = true; }
            else if (state.build === 'foam') { if (!hasSameType) allowed = true; }
            else { if (!hasFurniture) allowed = true; }

            if(allowed) {
                state.ents.push(new Ent(state.nextId++, tx, ty, state.build));
            }
        }

        // --- INPUT HANDLERS ---
        window.onmousedown = (e) => {
            state.mouse.down = true;
            const {gx, gy} = getTargetGrid(e);
            
            // Selecci√≥n (Solo click simple)
            const ent = state.ents.find(e => e.x===gx && e.y===gy && e.type !== 'foam' && e.type !== 'cable');
            if(ent && ent.type === 'socket' && !state.circuitBreaker) {
                state.circuitBreaker = true; alert("Plomos rearmados. Red el√©ctrica online."); return;
            }
            if(ent && (state.view==='normal' || !state.build)) { 
                state.sel = ent; document.getElementById('inspect').style.display='block'; return; 
            }

            // Iniciar Drag
            if(state.build) {
                state.dragStart = {x: gx, y: gy};
                tryBuild(gx, gy);
            }
        };

        window.onmouseup = () => {
            state.mouse.down = false;
            state.dragStart = null;
        };

        window.onmousemove = (e) => {
            const {gx, gy} = getTargetGrid(e);
            state.mouse.gx = gx; state.mouse.gy = gy;
            
            // Construcci√≥n Continua (Drag)
            if(state.mouse.down && state.build) {
                tryBuild(gx, gy);
            }
            
            // Pan de c√°mara (Solo si no construimos y usamos clic derecho o algo similar, pero aqui simplificamos a movementX si no construimos)
            if(state.mouse.down && !state.build) {
               state.cam.x += e.movementX; state.cam.y += e.movementY; 
            }
        };

        window.onkeydown = e => {
            const k = e.key.toLowerCase();
            const map = {'q':'normal','t':'thermal','e':'electric','r':'noise','s':'dirt'};
            if(map[k]) { state.view = map[k]; document.getElementById('mode').innerText = state.view.toUpperCase(); }
            if(k === 'escape') { setCursorMode(); return; }
            if(parseInt(k)) {
                state.build = ['miner','cable','ac_floor','ac_wall','foam'][parseInt(k)-1];
                setViewForBuild(state.build); 
            }
        };

        state.ents.push(new Ent(state.nextId++, -1, 2, 'socket')); 
        window.onresize = () => { canvas.width=window.innerWidth; canvas.height=window.innerHeight; };
        window.onresize();
        setInterval(() => { update(); draw(); }, 1000/60);

        window.repair = () => { 
            if(state.sel && state.sel.stat==='burn') { 
                state.sel.stat='ok'; 
                state.heat[state.sel.x+state.sel.y*GRID] = AMB_TEMP; 
                alert("¬°Reparado!"); 
            } 
        };
        window.sell = () => { 
            state.ents = state.ents.filter(e => e !== state.sel); 
            window.closeIns(); 
        };
        window.closeIns = () => { document.getElementById('inspect').style.display='none'; state.sel=null; };

    </script>
</body>
</html>